## Python Homework-1
基本语法、数据结构、函数
### （1）必做部分
在自然语言处理中，词频有十分重要的地位，在语义理解与主题建模等多个任务上有着广泛应用。你的任务如下：
对于给定的一段空格分隔的输入（仅包含小写英文字母），对其中出现的每个词，统计出现次数，并按照出现次数排序输出，
格式不限。
示例如下：
```
Input:aaa bbb ccc bb aaa bbb ccc aaa
Output:[('aaa', 3), ('ccc', 2), ('bbb', 2), ('bb', 1)]
```

### （2）提高部分（选做）
在细粒度的文本序列处理中处理中，BIO标签常常用于标定序列中的块。B代表一个块的开头，I表示在一个块的中间，
O表示不在块中。以下是一个例子，在这里我们为了简化，不考虑标点的情况。该句子中的目标块分别为iced tea和cheese pizza两个。

|I |like|the|iced|tea|and|the|cheese|pizza|
| :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: |
|O|O|O|B|I|O|O|B|I|

你的任务如下：
编写一个名称为bio_decoder的函数。参数接受一个元组的列表，每一个元组包含单词及其BIO标签。例如：
```
[('I','O'),('like','O'),('this','O'),('python','B'),('lecture','I'),('and','O'),('homework','B')]
```
期望的输出为
```
python lecture
homework
```
具体格式不作要求

## Python Homework-2
在深度学习领域，绝大部分的训练计算是基于张量(Tensor)进行的。简单来讲，一个一维的张量就是一个向量，二维的就是一个矩阵。你的任务是实现一个张量计算的模块。
### （1）必做部分
这里我们作尽可能的简化。我们只考虑一维情况，即向量。你的任务如下：
实现一个tensor_1d类，现将格式给定如下,你只需要填充相关代码。你可能需要用到math模块。
```
class tensor_1d:
    def __init__(self,vector):#可用tuple,list来初始化

    def shape(self):#返回向量长度

    def print(self):输出向量值

    def __add__(self, other):#重载向量相加,这里假设长度是相同的,下同
    
    def __sub__(self, other):#重载向量相减

    def __mul__(self, other):#重载向量智能相乘,这里指的是对应元素依次相乘

    def sum(self):#返回所有元素之和

    def exp(self):#返回一个向量，每个元素为原来对应元素的自然指数
    
    def log(self):#返回一个向量，每个元素为原来对应元素的自然对数,不考虑负值问题

```
一段示例的测试代码如下：
```
a=tensor_1d([1,2,3])
b=tensor_1d([4,5,8])
c=a+b
d=a-b
e=a*b
print((c+d+e).sum())
c.print()
d.exp().print()
e.log().print()
```
可能的输出为
```
50
[5, 7, 11]
[0.049787068367863944, 0.049787068367863944, 0.006737946999085467]
[1.3862943611198906, 2.302585092994046, 3.1780538303479458]
```
### （2）提高部分（选做）

#### Part 1
第一部分的每个函数的功能均可以在一行代码内完成(不使用分号),请尝试实现.
#### Part 2
如你所见，初始化以及重载的操作并不具有鲁棒性。因此做以下进一步的要求
* 采用默认参数，具体值可自定。并在初始化时进行类型检查,如果不是tuple或者list就抛出一个异常，异常类型自己指定即可。 提示：使用type()
* 在相加、相减和智能相乘的操作中，如果维度不同，抛出一个异常，异常类型自己指定即可。
### （3）挑战部分（自行尝试，不必提交）
将限定改为一维或者二维，初始化用二维列表或元组，功能任意添加。可包括矩阵乘积，按行求和，按列求和等等。